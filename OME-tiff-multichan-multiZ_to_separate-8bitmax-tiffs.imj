// ImageJ/Fiji macro: OME-TIFF -> per-channel 8-bit Z-max projections (VERBOSE, FIXED v3)
// Channels assumed fixed: C1=red, C2=green, C3=blue
// Output names: M###_sSSS.tiff  (e.g., M149_s051.tiff)
// Verbose console prints + % completion after each file.

macro "OME-TIFF per-channel Z-max to 8-bit [F5]" {

    // ------- user prompts -------
    inDir  = getDirectory("Choose INPUT directory containing OME-TIFFs");
    if (inDir=="") exit("No input directory selected.");
    outDir = getDirectory("Choose OUTPUT directory (will create channel subfolders)");
    if (outDir=="") exit("No output directory selected.");

    // ------- options you can tweak -------
    scaleConversions = true; // 16->8 bit scaling uses full range
    makePerChannelDirs(outDir); // ensures C1/C2/C3 dirs exist

    setOption("ScaleConversions", scaleConversions);

    // ------- collect candidate files (OME-TIFF only) -------
    all = getFileList(inDir);
    files = newArray(); // will hold only valid OME-TIFFs
    for (i=0; i<all.length; i++) {
        p = inDir + all[i];
        if (File.isDirectory(p)) continue;
        nm = toLowerCase(all[i]);
        if (endsWith(nm, ".ome.tif") || endsWith(nm, ".ome.tiff"))
            files = Array.concat(files, all[i]);
    }

    total = files.length;
    if (total==0) exit("No .ome.tif/.ome.tiff files found in:\n" + inDir);

    // print header (avoid unicode arrow)
    print("=== OME-TIFF per-channel Z-max -> 8-bit ===");
    print("Input dir : " + inDir);
    print("Output dir: " + outDir);
    print("Files to process: " + total);
    print("ScaleConversions (16->8): " + scaleConversions);
    print("------------------------------------------");

    setBatchMode(true);

    // process loop with progress
    for (idx=0; idx<total; idx++) {
        fname = files[idx];
        fpath = inDir + fname;

        // progress bar (0..1)
        showProgress(idx, total);

        // console: start
        print("\n[" + (idx+1) + "/" + total + "] Starting: " + fname);
        t0 = getTime();

        // Parse IDs
        sampleID = parseSampleID(fname);
        sceneNum = parseSceneNumber(fname);
        if (sampleID=="") sampleID = "UNKNOWN";
        if (sceneNum < 0) sceneNum = 0;
        sceneStr = zeroPad(sceneNum, 3);
        outBase = sampleID + "_s" + sceneStr + ".tiff";
        print("  Parsed -> sampleID: " + sampleID + " | scene: " + sceneStr + " | outBase: " + outBase);

        // Import as hyperstack (XYCZT)
        print("  Importing via Bio-Formats...");
        run("Bio-Formats Importer", "open=["+fpath+"] autoscale color_mode=Default view=Hyperstack stack_order=XYCZT");
        impTitle = getTitle();
        if (!isOpenWindow(impTitle)) {
            print("  [WARN] Failed to open image: " + fname + " â€” skipping.");
            continue;
        }

        // Split channels
        print("  Splitting channels...");
        run("Split Channels");

        // Process each expected channel
        savedC1 = processOneChannelVerbose("C1-" + impTitle, outDir + File.separator + "C1_red",   outBase, "C1/red");
        savedC2 = processOneChannelVerbose("C2-" + impTitle, outDir + File.separator + "C2_green", outBase, "C2/green");
        savedC3 = processOneChannelVerbose("C3-" + impTitle, outDir + File.separator + "C3_blue",  outBase, "C3/blue");
        savedCount = savedC1 + savedC2 + savedC3;

        // Close original if open
        if (isOpenWindow(impTitle)) { selectWindow(impTitle); close(); }

        // cleanup + timing
        call("java.lang.System.gc");
        dt = (getTime() - t0) / 1000.0;

        // percent complete
        pct = d2s( ( (idx+1.0) / total ) * 100.0, 1 );
        print("  Saved channels this file: " + savedCount + " | Elapsed: " + d2s(dt,2) + " s");
        print("  Progress: " + pct + "% (" + (idx+1) + " of " + total + ")");
    }

    // finalize
    showProgress(1,1);
    setBatchMode(false);
    print("\n=== Done. Processed " + total + " file(s). Output in: " + outDir + " ===");
    showMessage("Done", "Finished processing " + total + " file(s).\nOutput in:\n" + outDir);
}

// ====================== helper routines ======================

function makePerChannelDirs(base) {
    File.makeDirectory(base + File.separator + "C1_red");
    File.makeDirectory(base + File.separator + "C2_green");
    File.makeDirectory(base + File.separator + "C3_blue");
}

function processOneChannelVerbose(winTitle, outDirChan, outBase, label) {
    if (!isOpenWindow(winTitle)) {
        print("    [WARN] Missing channel window: " + label + " (" + winTitle + ")");
        return 0;
    }
    print("    Processing " + label + "...");
    selectWindow(winTitle);

    // Determine Z and project
    getDimensions(w, h, ch, z, t);
    if (z > 1) {
        print("      Z=" + z + " -> Max Intensity Projection");
        run("Z Project...", "start=1 stop="+z+" projection=[Max Intensity]");
        // Close source stack for this channel
        selectWindow(winTitle); close();
        projTitle = getTitle();
    } else {
        projTitle = winTitle;
        print("      Z=1 (no projection needed)");
    }

    // Convert to 8-bit and save
    selectWindow(projTitle);
    run("8-bit");
    savePath = outDirChan + File.separator + outBase;
    saveAs("Tiff", savePath);
    print("      Saved: " + savePath);

    // Close projection window
    close();
    return 1;
}

function parseSampleID(fname) {
    // Robust scan: find the first occurrence of 'M' or 'm' followed by >=1 digits anywhere in the name.
    s = fname;
    n = lengthOf(s);
    for (i = 0; i < n - 1; i++) {
        ch = substring(s, i, i+1);
        if (ch=="M" || ch=="m") {
            // collect consecutive digits after M/m
            j = i + 1;
            digits = "";
            while (j < n) {
                dch = substring(s, j, j+1);
                if (indexOf("0123456789", dch) >= 0) { digits = digits + dch; j++; }
                else break;
            }
            if (lengthOf(digits) > 0) return "M" + digits; // normalize to uppercase M
        }
    }
    // As a fallback, try dash-separated tokens like before (covers cases like "M149-Rotate ...")
    parts = split(fname, "-");
    for (k=0; k<parts.length; k++) {
        p = parts[k];
        if (startsWith(p, "M") && isAllDigits(substring(p,1))) return p;
        if (startsWith(p, "m") && isAllDigits(substring(p,1))) return "M" + substring(p,1);
    }
    return "";
}
    return "";
}

function parseSceneNumber(fname) {
    // Flexible parser: finds digits following 'scene' with -, _, or space delimiters.
    // Handles 'Scene-33', 'SCENE 033', 'scene_12', etc. Returns integer (leading zeros ok).
    s = normalizeAscii(toLowerCase(fname));
    n = lengthOf(s);
    best = -1; // fallback if multiple; we'll take the first valid occurrence
    for (i = 0; i <= n - 5; i++) {
        if (substring(s, i, i+5) == "scene") {
            k = i + 5;
            // skip common separators
            while (k < n) {
                ch = substring(s, k, k+1);
                if (ch == " " || ch == "-" || ch == "_") k++; else break;
            }
            // collect digits
            digits = "";
            while (k < n) {
                ch = substring(s, k, k+1);
                if (indexOf("0123456789", ch) >= 0) { digits = digits + ch; k++; }
                else break;
            }
            if (lengthOf(digits) > 0) {
                val = parseInt(digits);
                // return first match; if you prefer the largest match, compare and keep max
                return val;
            }
            // else continue scanning for next 'scene'
        }
    }
    return -1;
}

function normalizeAscii(s) {
    // Replace common Unicode hyphens and NBSP with ASCII equivalents to make parsing robust.
    out = "";
    for (ii = 0; ii < lengthOf(s); ii++) {
        ch = substring(s, ii, ii+1);
        code = ch.charCodeAt(0);
        // en dash (8211), em dash (8212), figure dash (8210), minus (8722)
        if (code==8211 || code==8212 || code==8210 || code==8722) out = out + "-";
        // NBSP (160) -> space
        else if (code==160) out = out + " ";
        else out = out + ch;
    }
    return out;
}
    if (lengthOf(num) == 0) return -1;
    return parseInt(num);
}

function zeroPad(num, width) {
    s = "" + num;
    while (lengthOf(s) < width) s = "0" + s;
    return s;
}

function isAllDigits(s) {
    s = "" + s;
    if (lengthOf(s) == 0) return false;
    for (k = 0; k < lengthOf(s); k++) {
        ch = substring(s, k, k+1);
        if (indexOf("0123456789", ch) < 0) return false;
    }
    return true;
}

function isOpenWindow(title) {
    titles = getList("image.titles");
    for (ii=0; ii<titles.length; ii++) if (titles[ii]==title) return true;
    return false;
}
